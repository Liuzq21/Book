## 大话设计模式六大原则

- 单一职责原则（SRP）：就一个类而言，应该仅有一个引起它变化的原因。
- 开放封闭原则（OCP）：软件实体（类、函数、模块等）应该可以扩展但不可修改。
  - 当变化发生时，创建抽象来隔离以后发生的同类变化。如设计了一个加法程序，而后需要增加一个减法功能。那么应该考虑重构程序，增加一个抽象的运算类，以便未来进行乘法和除法的扩展。当然在设计之初最好能预料到这一点。
- 依赖倒转原则：抽象不依赖细节，细节依赖抽象。高层模块不应该依赖底层模块。两个都应该依赖抽象。
  - 里氏替换原则：只有当子类可以替换父类时，父类才能被真正复用，子类也能在父类的基础上增加新的行为。
- 迪米特法则（知道的越少越好）（LoD）：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三方转发这个调用。——降低类的成员访问权限。
- 合成复用原则CARP：尽量首先使用合成/聚合的方式，而不是使用继承。

# 设计模式

**创建型模式**
共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

**结构型模式**
共七种：适配器模式、桥接模式、装饰者模式、代理模式、外观模式、组合模式、享元模式。

**行为型模式**
共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

## 创建型

### 工厂方法模式

![](S:.\pic\FactoryMethod.png)

### 抽象工厂模式

![](.\pic\AbstractFactory.png)

### 单例模式

![](.\pic\Singleton.png)

```c++
//Singleton类懒汉式，在第一次调用时实例化
class Singleton
{
public:
	static Singleton* getInstance()   // 通过getInstance来判断并在内部调用构造函数
	{	
		//m_mutex.lock(); 
		if (m_pSingleton == NULL)   // 这里在多线程环境下仍有可能创造多个对象。解决办法：上锁
		{
			m_pSingleton = new Singleton();
		}
		//m_mutex.unlock();
		return m_pSingleton;
	}
private:
	Singleton() {}      // 私有化构造函数使得外部无法调用
	static Singleton* m_pSingleton;
	//boost::mutex m_mutex;  
};

Singleton* Singleton::m_pSingleton = NULL;

class Singleton2 //饿汉式单例模式实现比较简单粗暴，直接在类外创建对象，当该类创建时对象即被创建，
{
private:
	Singleton2() {}

	static Singleton2* m_pSingleton;
public:
	static Singleton2* getInstance()
	{
		return m_pSingleton;
	}
};
```

### 建造者模式

将一个复杂对象的构建和表示分离，使得同样的构建过程可以创造不同的表示.

![](.\pic\Builder.png)

### 原型模式

![](.\pic\Prototype.png)

```c++
class Prototype {
	
public:
	Prototype() {}
	virtual ~Prototype() {}
	virtual Prototype* Clone() = 0;
};

class Resume :public Prototype {
	string name;
	string sex;
public:
	Resume(string n, string s) : name(n), sex(s){}
	~Resume() {}
	Resume* Clone() { return new Resume(*this); }  // 这里是调用拷贝构造
	Resume(const Resume& rhs) {  // 注意在拷贝构造里的深浅拷贝问题
		this->name = rhs.name;
		this->sex = rhs.sex;
	}
	void display() { std::cout << name << sex << std::endl; }
};
```

## 结构型

### 适配器模式

适配器模式：将一个类的接口转换成客户希望的另一个接口,可以使得接口不兼容的类一起工作。

适配器应该干两件事： 1. 继承Target 2. 包装Adaptee

![](.\pic\Adapter.png)

### 桥接器模式

桥接模式：将抽象部分与实现部分分离开来，使它们都可以独立的变化
与模板方法模式对比：
	模板方法模式是将通用接口虚函数化，通过子类对虚函数接口重载实现，这样就不需要定义大量的函数污染函数空间。
	而桥接模式与模板模式的不同在于桥接模式多了一个虚拟的桥接类，通过这个类的继承类来完成具体实现。

![](.\pic\Bridge.png)

### 组合模式

组合模式：将对象组合成树形结构表示‘部分-整体’的层次结构。
分为透明方式与安全方式。透明方式就是，在leaf结点中具备但无效的add与remove功能

![](.\pic\Composite.png)

### 装饰模式

![](.\pic\Decorator.png)

### 外观模式

![](.\pic\Facade.png)

### 享元模式

享元模式: 共享相同元素，不必为相同的元素new大量的实例，在需要时调取该对象即可, 一种是单纯享元，一种是复合享元，
单纯享元的特点是所有元素都是共享的，而复合享元角色对象是不共享的，但是一个复合享元内部对象可以划分为多个共享享元表示；
应用：如果一个应用程序使用了大量的对象，并且造成了很大的存储开销。如果删掉对象的大多数外部状态，可以用较少的共享对象取代。

![](.\pic\Flyweight.png)

```c++
class WebSite {
public:
	virtual void use() = 0; // 这个方法是可以带参数的即可以携带外部状态
};

class ConcreteWebSite : public WebSite {
	string name;
public:
	ConcreteWebSite(string s) :name(s) {}
	void use() override {
		cout << "网站分类" << name << endl;
	}
};

class WebSiteFactory {
	map<string, ConcreteWebSite*> map;  // 关键在于工厂里面用map存，做到不必为相同的元素new大量的实例
public:
	WebSite* getWeb(string key) {
		if (!map.count(key)) {    
			map[key] = new ConcreteWebSite(key);
		}
		return map[key];
	}

	int getWebCount() {
		return map.size();
	}
};
```

### 代理模式

![](.\pic\Proxy.png)

## 行为型

### 观察者模式

![](.\pic\Observe.png)

### 观察者模式进阶

实现不同观察者对主题更新，调用自定义的方法。

```c++
typedef function<int(int)> EventHandler;
map<Observer*, EventHandler> observers;  // 绑定了所有观察者极其update时要调用的函数
ConcreteObserver1 observer = ConcreteObserver1(concreteSubject);
EventHandler eh1 = bind(&ConcreteObserver1::update1, &observer, placeholders::_1);  // bind依次参数含义：执行的代码，调用次代码需要的对象，代码的传参个数
concreteSubject->Attach(&observer, eh1); // 把观察者及其update函数加进去
```

### 模板方法模式

![](.\pic\TemplateMethod.png)

### 命令模式

![](.\pic\Command.png)

### 状态模式

状态模式：当一个对象改变其内在状态时，允许改变其行为。这个对象看起来像是改变了其类。
实现的关键在于1.在用户中使用状态基类指针记录当前状态。2. 在不同状态中通过用户重新设定下一个状态并调用。

![](.\pic\State.png)

### 职责链模式

和状态模式类似。都是自己处理不了就丢给下一个。不同点在于：
	状态模式内部记录一个公共状态，对其进行判断是否处理。
	责任链模式内部记录一个继任者，接收一个请求，当请求不是自己的能处理时，递交给继任者。

![](.\pic\ChainOfResponsibility.png)

### 解释器模式

![](.\pic\Interpreter.png)

### 中介者模式

与代理模式的区别：
	代理者和被代理者都是继承自同一个接口。并且是代理者拥有一个被代理者的对象。
	中介者和委托人是来自不同的类。委托人拥有一个中介者对象。中介对象拥有多个委托人。

![](.\pic\Mediator.png)

### 访问者模式

![](.\pic\Visitor.png)

### 策略模式

![](.\pic\Strategy.png)

### 迭代器模式

![](.\pic\Iterator.png)
